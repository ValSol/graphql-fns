const createThingSchema=require("../../mongooseModels/createThingSchema"),processUpdateDuplexInputData=require("./processUpdateDuplexInputData"),processUpdateInputData=require("./processUpdateInputData"),processDeleteData=require("./processDeleteData"),updatePeriphery=require("./updatePeriphery"),createUpdateThingMutationResolver=a=>{return async(b,c,d)=>{const{mongooseConn:e}=d,{where:f,where:{id:h},data:g}=c,{name:i,duplexFields:j}=a,k=createThingSchema(a),l=e.model(i,k),m=j?j.reduce((a,{name:b})=>(g[b]&&(a[b]=1),a),{}):{},n=processUpdateInputData(g,a);let o,p=h;// eslint-disable-line no-underscore-dangle
if(Object.keys(m).length){const b=h?{_id:p}:f,c=await l.findOne(b,m,{lean:!0}),d={...g,_id:p},i=processDeleteData(c,a),{core:j,periphery:k}=processUpdateDuplexInputData(d,a,i);await updatePeriphery(k,e);const q=[];j.forEach((a,b)=>{const{name:c}=b,d=createThingSchema(b),f=e.model(c,d);q.push(f.bulkWrite(a))}),await Promise.all(q),o=await l.findOneAndUpdate({_id:p},n,{new:!0,lean:!0})}else if(h)p=h,o=await l.findOneAndUpdate({_id:p},n,{new:!0,lean:!0});else{if(o=await l.findOneAndUpdate(f,n,{new:!0,lean:!0}),!o)return null;p=o._id}return o.id=p,o}};module.exports=createUpdateThingMutationResolver;