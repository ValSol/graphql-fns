const checkInventory=require("../../utils/checkInventory"),createThingSchema=require("../../mongooseModels/createThingSchema"),processUpdateDuplexInputData=require("./processUpdateDuplexInputData"),processUpdateInputData=require("./processUpdateInputData"),processDeleteData=require("./processDeleteData"),updatePeriphery=require("./updatePeriphery"),createUpdateThingMutationResolver=(a,b)=>{const{enums:c,inventory:d}=b,{name:e}=a;if(!checkInventory(["Mutation","updateThing",e],d))return null;return async(b,f,g)=>{const{mongooseConn:h}=g,{whereOne:i,whereOne:{id:k},data:j}=f,{name:l,duplexFields:m}=a,n=createThingSchema(a,c),o=h.model(l,n),p=m?m.reduce((a,{name:b})=>(j[b]&&(a[b]=1),a),{}):{},q=processUpdateInputData(j,a);let r=k;// eslint-disable-line no-underscore-dangle
const s=k?{_id:r}:i,t=checkInventory(["Subscription","updatedThing",e],d)?{}:p,u=await o.findOne(s,t,{lean:!0});let v;if(Object.keys(p).length){const b={...j,_id:r},d=processDeleteData(u,a),{core:e,periphery:f}=processUpdateDuplexInputData(b,a,d);await updatePeriphery(f,h);const g=[];e.forEach((a,b)=>{const{name:d}=b,e=createThingSchema(b,c),f=h.model(d,e);g.push(f.bulkWrite(a))}),await Promise.all(g),v=await o.findOneAndUpdate({_id:r},q,{new:!0,lean:!0})}else if(k)r=k,v=await o.findOneAndUpdate({_id:r},q,{new:!0,lean:!0});else{if(v=await o.findOneAndUpdate(i,q,{new:!0,lean:!0}),!v)return null;r=v._id}if(v.id=r,checkInventory(["Subscription","updatedThing",e],d)){const{pubsub:a}=g;if(!a)throw new TypeError("Context have to have pubsub for subscription!");// to prevent flowjs error
const b=Object.keys(j);u.id=r;const c={node:v,previousNode:u,updatedFields:b};a.publish(`updated-${e}`,{[`updated${e}`]:c})}return v}};module.exports=createUpdateThingMutationResolver;