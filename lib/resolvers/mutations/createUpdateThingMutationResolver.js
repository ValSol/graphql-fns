const checkInventory=require("../../utils/checkInventory"),createThingSchema=require("../../mongooseModels/createThingSchema"),processUpdateDuplexInputData=require("./processUpdateDuplexInputData"),processUpdateInputData=require("./processUpdateInputData"),processDeleteData=require("./processDeleteData"),updatePeriphery=require("./updatePeriphery"),createUpdateThingMutationResolver=(a,b)=>{const{enums:c,inventory:d}=b,{name:e}=a;if(!checkInventory(["Mutation","updateThing",e],d))return null;return async(b,d,e)=>{const{mongooseConn:f}=e,{where:g,where:{id:i},data:h}=d,{name:j,duplexFields:k}=a,l=createThingSchema(a,c),m=f.model(j,l),n=k?k.reduce((a,{name:b})=>(h[b]&&(a[b]=1),a),{}):{},o=processUpdateInputData(h,a);let p,q=i;// eslint-disable-line no-underscore-dangle
if(Object.keys(n).length){const b=i?{_id:q}:g,d=await m.findOne(b,n,{lean:!0}),e={...h,_id:q},j=processDeleteData(d,a),{core:k,periphery:l}=processUpdateDuplexInputData(e,a,j);await updatePeriphery(l,f);const r=[];k.forEach((a,b)=>{const{name:d}=b,e=createThingSchema(b,c),g=f.model(d,e);r.push(g.bulkWrite(a))}),await Promise.all(r),p=await m.findOneAndUpdate({_id:q},o,{new:!0,lean:!0})}else if(i)q=i,p=await m.findOneAndUpdate({_id:q},o,{new:!0,lean:!0});else{if(p=await m.findOneAndUpdate(g,o,{new:!0,lean:!0}),!p)return null;q=p._id}return p.id=q,p}};module.exports=createUpdateThingMutationResolver;