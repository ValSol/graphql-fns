const{Types}=require("mongoose"),pointFromGqlToMongo=require("./pointFromGqlToMongo"),polygonFromGqlToMongo=require("./polygonFromGqlToMongo"),processCreateInputData=(a,b,// use mongoose Types in args to let mocking the ObjectId() in tests
c=Types)=>{const d=new Map,e=new Map,f=[{data:{...a,_id:c.ObjectId()},config:b}],g=(a,b)=>{const{duplexFields:h,embeddedFields:i,enumFields:j,geospatialFields:k,relationalFields:l,textFields:m}=b,n={};l&&l.reduce((a,{name:b,array:c,config:d})=>(a[b]={array:c,config:d},a),n);const o={};h&&h.reduce((a,{name:b,oppositeName:c,array:d,config:e})=>{if(!e.duplexFields)throw new TypeError("Expected a duplexFields in config!");const f=e.duplexFields.find(({name:a})=>a===c);if(!f)throw new TypeError(`Expected a duplexField with name "${c}"!`);const{array:g,config:h}=f;// eslint-disable-next-line
return a[b]={array:d,config:e,oppositeArray:g,oppositeConfig:h,oppositeName:c},a},o);const p={};i&&i.reduce((a,{name:b,config:c})=>(a[b]=c,a),p);const q={};k&&k.reduce((a,{name:b,array:c,type:d})=>(a[b]={array:c,type:d},a),q);const r=["_id"];return m&&m.reduce((a,{name:b})=>(a.push(b),a),r),j&&j.reduce((a,{name:b})=>(a.push(b),a),r),Object.keys(a).reduce((b,h)=>{if(n[h]){const{array:d,config:e}=n[h];if(!d&&a[h].create&&a[h].connect)throw new TypeError(`Simultaneous use "create" and "connect" keys with a relationalField "${h}" that not an array!`);if(a[h].connect&&(b[h]=a[h].connect),a[h].create)if(d){const d=a[h].connect||[];a[h].create.forEach(a=>{// eslint-disable-next-line no-underscore-dangle
const b=c.ObjectId();d.push(b),f.push({data:{...a,_id:b},config:e})}),b[h]=d}else{// eslint-disable-next-line no-underscore-dangle
const d=c.ObjectId();f.push({data:{...a[h].create,_id:d},config:e}),b[h]=d}}else if(o[h]){const{array:g,config:i,oppositeArray:j,oppositeConfig:k,oppositeName:l}=o[h];if(!g&&a[h].create&&a[h].connect)throw new TypeError(`Simultaneous use "create" and "connect" keys with a duplexField "${h}" that not an array!`);if(a[h].connect)if(g){const{connect:c}=a[h];// eslint-disable-next-line no-param-reassign
b[h]=c,c.forEach(b=>{const c={updateOne:{filter:{_id:b},update:j?// eslint-disable-next-line no-underscore-dangle
{$push:{[l]:a._id}}:// eslint-disable-next-line no-underscore-dangle
{[l]:a._id}}},f=d.get(i);if(f?f.push(c):d.set(i,[c]),!j){const a=e.get(i);a?a[l]?a[l].oppositeIds.push(b):a[l]={array:!0,name:h,oppositeConfig:k,oppositeIds:[b]}:e.set(i,{[l]:{array:!0,name:h,oppositeConfig:k,oppositeIds:[b]}})}})}else{const{connect:c}=a[h];// eslint-disable-next-line no-param-reassign
b[h]=c;const f={updateOne:{filter:{_id:c},update:j?// eslint-disable-next-line no-underscore-dangle
{$push:{[l]:a._id}}:// eslint-disable-next-line no-underscore-dangle
{[l]:a._id}}},g=d.get(i);if(g?g.push(f):d.set(i,[f]),!j){const a=e.get(i);a?a[l]?a[l].oppositeIds.push(c):a[l]={array:!1,name:h,oppositeConfig:k,oppositeIds:[c]}:e.set(i,{[l]:{array:!1,name:h,oppositeConfig:k,oppositeIds:[c]}})}}if(a[h].create)if(g){const d=a[h].connect||[];a[h].create.forEach(b=>{// eslint-disable-next-line no-underscore-dangle
const e=c.ObjectId();d.push(e),f.push({data:{...b,_id:e,// eslint-disable-next-line no-underscore-dangle
[l]:j?[a._id]:a._id},config:i})}),b[h]=d}else{// eslint-disable-next-line no-underscore-dangle
const d=c.ObjectId();f.push({data:{...a[h].create,_id:d,// eslint-disable-next-line no-underscore-dangle
[l]:j?[a._id]:a._id},config:o[h].config}),b[h]=d}a[h].connect||a[h].create||!a[h]||(b[h]=a[h])}else if(p[h])// eslint-disable-next-line no-param-reassign
b[h]=g(a[h],p[h]);else if(q[h]){const{array:c,type:d}=q[h];c?("Point"===d&&(b[h]=a[h].map(a=>pointFromGqlToMongo(a))),"Polygon"===d&&(b[h]=a[h].map(a=>polygonFromGqlToMongo(a)))):("Point"===d&&(b[h]=pointFromGqlToMongo(a[h])),"Polygon"===d&&(b[h]=polygonFromGqlToMongo(a[h])))}else r.includes(h)&&(// eslint-disable-next-line no-param-reassign
b[h]=a[h]);return b},{})};let h=null;for(;f.length;){const{data:a,config:b}=f.shift(),c=g(a,b);h||(h=c);const e={insertOne:{document:c}},i=d.get(b);i?i.push(e):d.set(b,[e])}let i=!1;if(1===d.size){const a=d.keys().next().value;if(!a)throw new TypeError("Expected an config object as key of \"core\" Map");const b=d.get(a);if(!b)throw new TypeError("Expected an array as value of \"core\" Map");1===b.length&&(i=!0)}return{core:d,periphery:e,single:i,first:h}};module.exports=processCreateInputData;