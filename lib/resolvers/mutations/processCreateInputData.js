const{Types}=require("mongoose"),processCreateInputData=(a,b,// use mongoose Types in args to let mocking the ObjectId() in tests
c=Types)=>{const d=new Map,e=new Map,f=[{data:{...a,_id:c.ObjectId()},config:b}],g=(a,b)=>{const{duplexFields:h,embeddedFields:i,relationalFields:j,textFields:k}=b,l={};j&&j.reduce((a,{name:b,array:c,config:d})=>(a[b]={array:c,config:d},a),l);const m={};h&&h.reduce((a,{name:b,oppositeName:c,array:d,config:e})=>{if(!e.duplexFields)throw new TypeError("Expected a duplexFields in config!");const f=e.duplexFields.find(({name:a})=>a===c);if(!f)throw new TypeError(`Expected a duplexField with name "${c}"!`);const{array:g,config:h}=f;// eslint-disable-next-line
return a[b]={array:d,config:e,oppositeArray:g,oppositeConfig:h,oppositeName:c},a},m);const n={};i&&i.reduce((a,{name:b,config:c})=>(a[b]=c,a),n);const o=["_id"];return k&&k.reduce((a,{name:b})=>(a.push(b),a),o),Object.keys(a).reduce((b,h)=>{if(l[h]){const{array:d,config:e}=l[h];if(!d&&a[h].create&&a[h].connect)throw new TypeError(`Simultaneous use "create" and "connect" keys with a relationalField "${h}" that not an array!`);if(a[h].connect&&(b[h]=a[h].connect),a[h].create)if(d){const d=a[h].connect||[];a[h].create.forEach(a=>{// eslint-disable-next-line no-underscore-dangle
const b=c.ObjectId();d.push(b),f.push({data:{...a,_id:b},config:e})}),b[h]=d}else{// eslint-disable-next-line no-underscore-dangle
const d=c.ObjectId();f.push({data:{...a[h].create,_id:d},config:e}),b[h]=d}}else if(m[h]){const{array:g,config:i,oppositeArray:j,oppositeConfig:k,oppositeName:l}=m[h];if(!g&&a[h].create&&a[h].connect)throw new TypeError(`Simultaneous use "create" and "connect" keys with a duplexField "${h}" that not an array!`);if(a[h].connect)if(g){const{connect:c}=a[h];// eslint-disable-next-line no-param-reassign
b[h]=c,c.forEach(b=>{const c={updateOne:{filter:{_id:b},update:j?// eslint-disable-next-line no-underscore-dangle
{$push:{[l]:a._id}}:// eslint-disable-next-line no-underscore-dangle
{[l]:a._id}}};d.get(i)?d.get(i).push(c):d.set(i,[c]),j||(e.get(i)?e.get(i)[l]?e.get(i)[l].oppositeIds.push(b):e.get(i)[l]={array:!0,name:h,oppositeConfig:k,oppositeIds:[b]}:e.set(i,{[l]:{array:!0,name:h,oppositeConfig:k,oppositeIds:[b]}}))})}else{const{connect:c}=a[h];// eslint-disable-next-line no-param-reassign
b[h]=c;const f={updateOne:{filter:{_id:c},update:j?// eslint-disable-next-line no-underscore-dangle
{$push:{[l]:a._id}}:// eslint-disable-next-line no-underscore-dangle
{[l]:a._id}}};d.get(i)?d.get(i).push(f):d.set(i,[f]),j||(e.get(i)?e.get(i)[l]?e.get(i)[l].oppositeIds.push(c):e.get(i)[l]={array:!1,name:h,oppositeConfig:k,oppositeIds:[c]}:e.set(i,{[l]:{array:!1,name:h,oppositeConfig:k,oppositeIds:[c]}}))}if(a[h].create)if(g){const d=a[h].connect||[];a[h].create.forEach(b=>{// eslint-disable-next-line no-underscore-dangle
const e=c.ObjectId();d.push(e),f.push({data:{...b,_id:e,// eslint-disable-next-line no-underscore-dangle
[l]:j?[a._id]:a._id},config:i})}),b[h]=d}else{// eslint-disable-next-line no-underscore-dangle
const d=c.ObjectId();f.push({data:{...a[h].create,_id:d,// eslint-disable-next-line no-underscore-dangle
[l]:j?[a._id]:a._id},config:m[h].config}),b[h]=d}a[h].connect||a[h].create||!a[h]||(b[h]=a[h])}else n[h]?// eslint-disable-next-line no-param-reassign
b[h]=g(a[h],n[h]):o.includes(h)&&(// eslint-disable-next-line no-param-reassign
b[h]=a[h]);return b},{})};let h=null;for(;f.length;){const{data:a,config:b}=f.shift(),c=g(a,b);h||(h=c);const e={insertOne:{document:c}};d.get(b)?d.get(b).push(e):d.set(b,[e])}let i=!1;if(1===d.size){const a=d.keys().next().value;if(!a)throw new TypeError("Expected an config object as key of \"core\" Map");const b=d.get(a);if(!b)throw new TypeError("Expected an array as value of \"core\" Map");1===b.length&&(i=!0)}return{core:d,periphery:e,single:i,first:h}};module.exports=processCreateInputData;