const mongoose=require("mongoose"),{Schema}=mongoose,composeThingSchemaProperties=a=>{const{isEmbedded:b,duplexFields:c,embeddedFields:d,geospatialFields:e,relationalFields:f,textFields:g}=a,h={};if(g&&g.reduce((a,{array:c,default:d,index:e,name:f,required:g,unique:h})=>{if(d){if(!c&&"string"!=typeof d)throw new TypeError("Expected a string as default value");if(c&&!Array.isArray(d))throw new TypeError("Expected an array as default value")}if((e||h)&&b)throw new TypeError("Must not have an \"index\" or \"unique\" field in an embedded document!");// eslint-disable-next-line no-param-reassign
// eslint-disable-line no-param-reassign
return a[f]={default:d||(c?[]:""),type:c?[String]:String},g&&(a[f].required=!!g),h&&(a[f].unique=!!h),e&&!h&&(a[f].index=!!e),a},h),f&&f.reduce((a,{array:c,config:{name:g},index:d,name:e,required:f})=>{if(d&&b)throw new TypeError("Must not have an \"index\" field in an embedded document!");const h={ref:g,type:Schema.Types.ObjectId};return f||(h.required=!!f),d&&(h.index=!!d),a[e]=c?[h]:h,a},h),c){if(b)throw new TypeError("Must not have an \"duplexField\" in an embedded document!");c.reduce((a,{array:b,config:{name:f},index:c,name:d,required:e})=>{// the same code as for relationalFields
const g={ref:f,type:Schema.Types.ObjectId};return e||(g.required=!!e),c&&(g.index=!!c),a[d]=b?[g]:g,a},h)}return d&&d.reduce((a,{array:b,name:c,config:d})=>{const e=composeThingSchemaProperties(d);// eslint-disable-next-line no-param-reassign
return a[c]=b?[e]:e,a},h),e&&e.reduce((a,{array:b,name:c,required:d,type:e})=>{if("Point"===e){const e={type:{type:String,enum:["Point"]},coordinates:{type:[Number],index:"2dsphere"}};d&&(e.required=!!d),a[c]=b?[e]:e}else if("Polygon"===e){const e={type:{type:String,enum:["Polygon"]},coordinates:{type:[[[Number]]]}};d&&(e.required=!!d),a[c]=b?[e]:e}else throw new TypeError(`Invalid value "${e}" of geospatial field type!`);return a},h),h};module.exports=composeThingSchemaProperties;